
[[Process]]내의 제어 흐름을 말한다. CPU utilization의 기본 단위로서 다음의 정보들로 구성된다.
+ Thread ID, [[PC(Program Counter)]], register set, stack

같은 [[Process]]내에 속한 다른 [[Thread]]들과 code, data, OS resource를 공유한다. 위에 서술한 정보들은 공유하지 않고 고유한 값들을 유지한다.

[[Process]]가 다중 [[Thread]] 제어가 가능하다면 하나 이상의 작업을 동시에 수행할 수 있다.

## Multi-thread Program
---
현대 [[운영체제(Operating System)]]에서 수행되는 많은 SW들이 지원하는 기능

현재 많은 [[운영체제(Operating System)]] Kernel이 multi-thread를 기반으로 동작한다. [[운영체제(Operating System)]]내의 모듈들이 thread로 관리되고 실행된다. 각 thread는 장치를 관리하거나 [[인터럽트(Interrupt)]]를 처리하는 등의 특정 작업을 수행한다.

### Benefits
+ Responsiveness: 하나의 프로그램이 차단되어도 수행을 계속하게 하거나 긴 연산을 수행하도록 한다
+ Resource Sharing: 프로세스에게 소유된 메모리와 자원을 공유한다
+ Economy: 하나의 프로세스 내의 thread는 자원을 공유하기 때문에 생성과 context-switch을 수행함에 있어 더 경제적이다. e.g. solaris: 프로레스 생성하는 시간 < thread 생성 시간 $\times \;30$
+ Utilization of Multi-Processor Architectures: thread는 서로 다른 프로세서에서 병렬로 실행될 수 있음

## Types
---
두 종류의 타입이 존재하며 각각 user, kernel thread라고 한다. 일반적으로 user thread들은 kernel thread보다 더 빨리 생성되고 관리된다. (kernel의 개입이 필요하지 않기 때문)
### User Thread
프로그래머에게 보이고, 커널에게 알려지지 않은 thread

User-level threads library에 의해 관리가 이루어지며 kernel 위에서 지원되나 kernel의 지원 없이 관리된다. 

e.g. POSIX Pthreads, Win32 threads, Java threads

### Kernel Thread
[[운영체제(Operating System)]] Kernel이 지원하고 관리하는 thread

e.g. Windows XP/2000/Vista/7/8, Solaris, Linux, Tru64 UNIX, Mac OS X

## Multithreading Models
---
user thread와 kernel thread 사이의 관계를 정의한 모델을 말하고 크게 3개로 구분된다. 
### Many-to-One
---
많은 user thread들이 하나의 kernel thread에 매핑된다.  thread 관리는 thread library에 의해 이루어진다. 
#### 장점
+ 사용자가 원하는 만큼의 많은 user thread를 생성할 수 있어 효율적
#### 단점
+ 하나의 thread가 block되는 경우 전체 process가 block된다.
+ 한 번의 하나의 thread만이 kernel에 접근할 수 있기 때문에 [[Multi-processor system]]에서도 병렬로 작동할 수 없다
#### 예제
+ Solaris Green Threads
+ GNU Portable Threads
### One-to-One
---
각 user thread는 하나의 kernel thread와 매핑된다. 
#### 장점
+ Many-to-One 모델보다  더 많은 병렬성을 제공한다
+ 하나의 theard가 block되더라도 다른 thread가 수행될 수 있다
#### 단점
+ user thread를 생성하기 위해서는 kernel thread를 생성하는 것을 필요로 하기 때문에 overhead
+ 하나의 process가 생성할 수 있는 thread의 수는 Many-to-One 모델보다 적다. 
#### 예제
+ Windows NT/XP/2000
+ Linux
+ Solaris 9 and later
### Many-to-Many
---
1개 이상의 user thread가 그와 같거나 더 적은 kernel thread들과 매핑된다. 
#### 장점
+ [[운영체제(Operating System)]]가 충분한 수의 kernel thread를 생성하도록 한다. 이로 인해 생성, 관리가 One-to-One 모델보다 효율적이다. 
+ kernel thread의 수가 응용프로그램이나 기계에 따라 결정된다. 
#### 단점
+ 구현이 매우 복잡하다
#### 예제
+ Solaris prior to version 9
+ Windows NT/2000 with the ThreadFber package

### Two-level Model
---
Many-to-Many 모델의 일종으로 많은 user thread를 같은 수나 더 적은 kernel thread로 다중화 시킨다. 그러나 하나의 user thread가 kernel thread에 종속되도록 허용한다.

즉 Many-to-Many 처럼 작동되는 부분이 존재하고, Many-to-One처럼 작동되는 부분이 존재한다. 
#### 예제 
+ IRIX
+ HP-UX
+ Tru64 Unix
+ Solaris 8 and earlier


## Thread Libraries
---
프로그래머에게 thread를 생성하고 관리하기 위한 [[API(Application Program Interface)]]를 제공

### Implement
+ 라이브러리를 kernel의 지원없이 사용자 공간에서 전부 제공한다
	+ 라이브러리를 위한 모든 코드와 데이터 구조는 user space에 존재
	+ 모든 함수 호출은 user mode에서 실행된다.
+ [[운영체제(Operating System)]]에 의해 지원 받는 kernel level library를 구현
	+ 모든 코드와 데이터 구조는 kernel space에 존재
	+ 모든 함수 호출은 kernel의 [[System Call]]을 야기
### Main Thread libraries
#### Pthreads
thread 생성과 동기화를 위한 POSIX 표준([IEEE 1003.1c]) API. UNIX OS에서 일반적
#### Windows Threads
One-to-One 매핑으로 구현되고 각 thread는 다음과 같은 정보를 포함
+ thread id
+ register set
+ separate user and kernel stacks
+ private data storage area
여기서 register set, stacks, private storage area는 thread의 context라고 말한다

또한 thread의 기본 데이터 구조는 다음을 포함한다
+ ETHREAD(executive thread block)
+ KTHREAD(kernel thread block)
+ TEB(thread environment block)
#### Java Threads
JVM에 의해 관리되는 thread로, 다음에 의해 생성된다
+ Extending Thread class
+ Implementing the Runnable interface

JVM은 host OS 위에서 실행되기 때문에 java thread API는 전형적으로 host system에서 실행 가능한 thread libary를 사용하여 구현된다.

![[Pasted image 20231017232131.png | 600]]

## Thread Issues
---
### Semantics of **fork()** and **exec()** [[System Call]]s
**fork()** 는 별도의 복제된 process를 생성한는 데 사용된다. 만약 한 프로그램의 thread가 fork()를 호출하면 다음과 같은 이슈가 존재한다
+ 새로운 process는 모든 thread를 복제해야 하는가?
+ 아니면 한 개의 thread만 가지는 process여야 하는가?
### Thread cancellation
therad가 정상적으로 종료되기 전에 다른 thread에 의해 종료되는 것을 말함. 취소하는 방법으로는 일반적으로 두 가지 방법이 존재한다
+ Asynchronous cancellation: 한 thread가 target thread를 종료시킴
	+ 자원이 취소된 thread에 할당되어 있거나 다른 thread와 자원을 공유하고 있는 thread가 데이터를 갱신시키는 도중에 취소 요청이 온 경우 문제가 생길 수 있음
+ Deferred cancellation: 취소 요청 이후 target thread가 주기적으로 자신이 취소되어야 하는지 확인하는 것을 허용한다. 
	+ 취소는 target thread가 취소 여부를 경정한 후에 이루어지며 이를 위해 flag를 검사한 후 수행된다
### Signal handling
Signals은 UNIX에서 process에게 어떤 사건이 일어났음을 알려주기 위해 사용하는 도구이다. 다음과 같은 두가지 유형이 존재한다
+ Synchronus signals: 연산의 결과에 관한 signal e.g. 불법적인 메모리 접근, 0으로 나누기
+ Asynchronous signals: 외부의 작업으로 인해 임의로 생성된 signal e.g. specific keystrokes(Ctrl-C), 타이머 만료

신호가 발생하면 다음과 같은 작업이 수행된다.
+ Signal is generated by particular event
+ Signal is delivered from kernel to a process
+ Signal is handled

모든 siganl은 default signal handler 혹은 user-defined signal handle에 의해 처리된다. 

Multi-threaded process의 경우 signal handling이 매우 복잡하다. 이 처리에는 다음과 같은 선택이 존재한다. 하지만 일반적으로 main thread에게 모든 신호가 전달된다.
+ 신호가 적용될 thread에게 전달
+ process 내의 모든 thread에게 전달
+ process 내의 몇몇 thread에게만 선택적으로 전달
+ 특정 thread가 모든 신호를 전달받도록 지정
### Thread pools
thread가 작업을 기다리고 있는 곳으로, 다음과 같은 특지이 존재한다. 
+ process는 시작될 때 일정 수의 thread를 생성해 thread pool에 놓는다
+ 요청을 받으면 서버는 thread pool로부터 thread를 깨워서 요청을 전달한다
+ thread가 해당 요청을 모두 수행하면 다시 thread pool로 반환되고 다음 작업을 기다린다
+ 만약 thread pool이 가용한 thread를 포함하지 않으면 서버는 thread pool안에 사용가능한 thread가 생길 때까지 기다린다.
#### 장점
+ 이미 생성된 thread에 요청하는 것이 새로운 thread를 생성하는 것보다 더 빠르게 수행된다
+ 응용 프로그램에서 thread의 수가 thread pool 크기에 종속되어 관리할 수 있다

#### 단점
+ 처음 process를 생성하는 데 시간이 걸리고, 평균 memory 사용률이 증가한다
### Thread specific data
procee에 속한 thread들은 process와 데이터를 공유하게 된다. 이러한 상황에서 각 thread는 자기 자신만의 데이터가 필요한 경우가 생길 수 있다.

이러한 데이터를 thread specific data라고 하고 다음과 같은 특징을 가진다. 
+ 각 thread는 자기 자신만의 데이터 복사본을 갖도록 함
+ thread 생성 과정에 대한 제어권이 없을 때 유용한 기능이다. (i.e. using thread pool)

대부분의 thread libraries는 thread specific data를 지원하기 위한 형식을 제공
### Scheduler activations
Many-to-Many와 Two-level 모델 모두 응용프로그램에 할당된 kernel thread 수를 적당히 유지하기 위한 통신을 필요로 한다. 이를 위해 sheduler activation을 사용한다.

Sheduler activations은 *upcalls*를 제공하고, 이는 kernel에서부터 thread libary로 통신하는 방법을 말한다


