>A integer $p>1$ is *prime number* iff only divisors are $\pm1$ and $\pm p$. All numbers other than $\pm1$ and the prime numbers are *composite numbers*.

위의 정의에 따라 1보다 큰  임의의 정수 $a$는 다음과 같이 표현할 수 있다. $$a=p_1^{a_1}\times p_1^{a_1}\times p_2^{a_2}\times...\times p_t^{a_t} \quad where \; p_1 < p_2 < ... <p_t \; are \; prime \; numbers\; and \; a_i \; is \; a \; positive \; integer$$위 식을 모든 prime number의 집합 $P$를 통해 표기하면 아래와 같다.$$a= \prod_{p\in P} p^{a_p} \quad where \; each \; q_p \geq 0$$위 식을 통하면 두 수에 대한 곱셈을 다음과 같이 표기 할 수 있다. $$\begin{align}a =\prod_{p\in P} p^{a_p} && b = \prod_{p\in P} p^{b_p} \qquad k=ab \\ k = \prod_{p\in P} p^{k_p} && where \; k_p = a_p+b_p  \; for \; all \; p \in P &\end{align}$$위 $a, b, k$에 대해 다음과 같은 수식도 성립하게 된다. $$if \; a|b, \; then \; a_p \leq b_p \; for \; all \; p$$$$if \; k = gcd(a, b), \; then \; k_p = min(a_p, b_p) \; for\; all\; p$$

## Testing for primality
---
많은 [[암호화 알고리즘(Cypotographic algorithms)]]에서 하나 혹은 더 많은 크기가 큰 prime number를 랜덤으로 선택하는 것이 필요할 때가 종종 존재한다. 

### Traditionally
trial divison을 이용해 큰 prime number를 찾아냈다. 모든 수에 대해 나누기를 수행해 $Z_p \equiv \phi(p)$인 $p$를 찾았다. 하지만 이러한 것은 매우 많은 시간이 걸렸고, 오직 값이 작은 수에 대해서만 가능했다. 이러한 이유로 통계적인 방법을 사용해 prime number를 찾게 되었다
### Miller-Rabin Algorithm
[[Fermat's Theorem]]를 기초로 한 방법으로 다음과 같은 알고리즘으로 수행된다. 
1. Any positive odd integer $n\geq 3$ can be expressed as $$n-1 = 2^kq \qquad with \; k > 0,\; q \; is \; odd$$
2. Select a random number $a \; where\; 1<a<n-1$
3. $if \; a^q \bmod \; n=1$, then return "inconclusive"
4. $for ; i=0 \; to \; k-1\; do \;that \quad if \; a^{2^iq} \bmod n = n-1$, then return "inconclusive"
5. return "composite"

결과가 composite가 나온다면 $n$은 prime이 아니다. 그 외의 결과의 경우 prime이거나 pseudo-prime이다.  다른 값인 $a$를 $t$번 사용한다고 하면 a가 모두 pseudo-prime일 확률은 최대 $(\frac{1}{4})^t$이다. 그러므로 충분히 큰 값 $t$을 시도한다고 했을 때 항상 inconclusive 결과를 내놓는다면 $n$은 prime이라고 할 수 있다. 


## Distribution of Primes
---
소수 검정을 사용하여 prime이 발견되기 전에 기각될 가능성이 있는 수가 몇 개인지에 대해 주목할 필요가 있다. 소수 정리로 알려진 수론의 결과는 $n$ 근처의 prime들이 평균적으로 $ln(n)$개의 정수만큼 이격되어 있음을 말하고 있다. 그러므로 평균적으로 소수 검정에는 $ln(n)$ 개의 정수순서에 대해 테스트를 해야 한다. 모든 짝수는 prime이 아니기 때문에 정확한 수치는 $0.5ln(n)$이다. 

e.g. 만약 $n=2^{200}$ 규모에 대한 prime을 찾기 위해서는 약$0.5 ln(2^{200}) = 69$번의 시행이 필요하다. 하지만 이 수치는 단순히 평균에 불과한 수치이다. 

## Primitive Roots
---
[[Euler Totient Function#Euler's Theorem]]을 기초한 것으로, 이 식에서 $\phi(n) = m$이라고 정의하면 다음과 같다. $$a^m \equiv 1 \pmod n$$이때 위 식을 만족하는 최소 양의 지수 $m$은 다음과 같이 언급된다
+ The order of $a\pmod n$
+ The exponent of which $a$ belongs $\pmod n$
+ The length of the period generated by $a$

좀 더 일반적으로 어떤 수가 $\pmod n$에 속할 수 있는 가능한 최고 지수는 $\phi(n)$이라고 할 수 있다. 만약 어떤 수가 이러한 차수에 속한다면 그것은 $n$의 *primitive root*라고 한다. 여기서 중요한 것은 만약 $a$가 $n$의 *primative root*라면 그것의 거듭 제곱들 $$a, a^2, ..., a^{\phi(n)}$$은 서로 distinct하고$\pmod n$ 모두 $n$과 *primatively root*이다. 특히 prime $p$이고, $a$가 $p$의 *primitive root*인 경우에 $$a, a^2, ..., a^{p-1}$$은 서로 distinct하고 $\pmod p$. e.g. $p=19$,  *primatively root*는 $2, 3, 10, 13, 14, 15$이다 